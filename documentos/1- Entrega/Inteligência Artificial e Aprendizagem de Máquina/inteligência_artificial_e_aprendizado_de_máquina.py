# -*- coding: utf-8 -*-
"""Inteligência Artificial e Aprendizado de Máquina.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TiqHC8HIPg5F3q5yRj8F7SBsMarnUDvv

##Entrega 1- Inteligência Artificial e Aprendizado de Máquina
"""

from google.colab import files
files.upload()

"""# Dados trabalhados"""

import pandas as pd
import numpy as np
import json

df2 = pd.read_json("Dados de pedidos - Cannoli.json")

df2.to_csv("Dados de pedidos - Cannoli.csv", index=False)
df2.head()

"""###Limpeza e a soma de dados nulos"""

df2.describe()
df2.isnull().sum()

"""###Visualização dos preços"""

import json
import pandas as pd

# Ler JSON
with open("Dados de pedidos - Cannoli.json", "r", encoding="utf-8") as f:
    dados = json.load(f)

# Lista para armazenar preços e nomes
precos = []


for pedido in dados:
    if "items" in pedido:
        for item in pedido["items"]:
            if "unitPrice" in item and "name" in item:
                precos.append({"name": item["name"], "unitPrice": item["unitPrice"]})

# Criar DataFrame
df_precos = pd.DataFrame(precos)

print(df_precos.shape)

df2.dropna()

"""#dados"""

df = pd.read_csv("Order_semicolon.csv", sep=';')
df.dropna()
df.head(200)

!pip install -U pandas-profiling

!pip install -U ydata-profiling

from ydata_profiling import ProfileReport

perfil=ProfileReport(df, title = "Análise Exploratória de Dados", html = {"style":{"full_with": False}})

colunas_especificas = ['status', 'totalAmount', 'createdAt']
perfil=ProfileReport(df[colunas_especificas], title = "Análise Exploratória de Dados", html = {"style":{"full_with": False}})

perfil.to_notebook_iframe()

"""##Quantidade de pedidos por status:

#
"""

# Contagem de pedidos por status
pedidos_status = df_faturamento.groupby("status").size()
print("Quantidade de pedidos por status:")
print(pedidos_status)

# Total de faturamento por status
faturamento_status = df_faturamento.groupby("status")["faturamento"].sum()
print("\nFaturamento total por status:")
print(faturamento_status)

"""##Treinamento de máquina para pprevisibilidade de Faturamento"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import LabelEncoder

# Transformar status em número
le = LabelEncoder()
df_faturamento["status_num"] = le.fit_transform(df_faturamento["status"])

# Número de itens por pedido
df_faturamento["num_itens"] = [len(pedido.get("items", [])) for pedido in dados]


X = df_faturamento[["status_num", "num_itens"]]
y = df_faturamento["faturamento"]

# Dividir treino/teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Treinar modelo
model = LinearRegression()
model.fit(X_train, y_train)

# Previsão
y_pred = model.predict(X_test)

# Mostrar previsão
print("\nFaturamento real:", list(y_test))
print("Faturamento previsto:", list(y_pred))



"""## Gráfico identifica a previsão de faturamento por preços



*   UnitPrice
*   status

É possivel verificar que o faturamento é ate um resultado bom devido ao coeficiente R2=1.000.


"""

import pandas as pd
import json
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import LabelEncoder
from yellowbrick.regressor import PredictionError

# Ler JSON
with open("Dados de pedidos - Cannoli.json", "r", encoding="utf-8") as f:
    dados = json.load(f)

# Preparar DataFrame de faturamento por pedido
rows = []
for pedido in dados:
    order_id = str(pedido.get("id")).strip()
    status = pedido.get("status")
    items = pedido.get("items", [])
    total_price = sum([item.get("unitPrice", 0) for item in items])
    rows.append({
        "id": order_id,
        "status": status,
        "faturamento": total_price,
        "num_itens": len(items)
    })

df_faturamento = pd.DataFrame(rows)

# Transformar status em números
le = LabelEncoder()
df_faturamento["status_num"] = le.fit_transform(df_faturamento["status"])

# Features e target
X = df_faturamento[["status_num", "num_itens"]]
y = df_faturamento["faturamento"]

# Dividir treino/teste
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# Criar modelo de regressão
model = LinearRegression()
model.fit(X_train, y_train)

# Visualizar erro de previsão com Yellowbrick
visualizer = PredictionError(model)
visualizer.fit(X_train, y_train)
visualizer.score(X_test, y_test)
visualizer.show()

!pip install --quiet yellowbrick

"""#Gráfico que deveria mostra a quantidade meses por pedidos"""



from yellowbrick.datasets import load_credit
from yellowbrick.features import Rank1D
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

df = pd.read_csv("Order_semicolon.csv", sep=";")

# Converter datas
df['createdAt'] = pd.to_datetime(df['createdAt'], dayfirst=True, errors='coerce')
#X, y = load_credit()

visualizador = Rank1D(algorithm='shapiro')

visualizador.fit(X,y)
visualizador.transform(X)
visualizador.show()

"""## Grafico mostra valores de faturamento

###A análise de correlação evidencia que apenas a variável número de itens por pedido (num_itens) apresenta uma relação moderada a forte com o faturamento, confirmando que pedidos maiores tendem a gerar maior receita. Em contrapartida, a variável status do pedido (status_num) demonstra correlação quase nula tanto com o número de itens quanto com o faturamento, indicando baixo poder preditivo.
"""

import pandas as pd
from yellowbrick.features import Rank2D

# Carregar CSV
df = pd.read_csv("Order_semicolon.csv", sep=";")

# Converter datas
df['createdAt'] = pd.to_datetime(df['createdAt'], dayfirst=True, errors='coerce')


#X2, y2 = load_credit()


#visualizdor2.fit(X2,y2)
visualizdor = Rank2D(algorithm="pearson")
visualizdor.fit_transform(X)
visualizdor.show()

"""##gráfico é uma visualização de dispersão que mostra como os diferentes status de pedidos estão distribuídos ao longo do tempo



*  Não há períodos específicos com um número significativamente maior ou menor de pedidos em um determinado status. Isso sugere que a operação é consistente e não tem grandes picos ou quedas sazonais para nenhum dos status.



"""

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder

# Carregar CSV
df = pd.read_csv("Order_semicolon.csv", sep=";")

# Converter datas
df['createdAt'] = pd.to_datetime(df['createdAt'], dayfirst=True, errors='coerce')

# Remover nulos
df = df.dropna(subset=['createdAt', 'status'])

# Selecionar apenas status desejados
status_desejados = ['DISPATCHED','PLACED','CONFIRMED','CONCLUDED','CANCELED']
df = df[df['status'].isin(status_desejados)]

# Converter status para números (para usar no gráfico)
le = LabelEncoder()
df['status_num'] = le.fit_transform(df['status'])

# Gráfico de dispersão
plt.figure(figsize=(12,6))
plt.scatter(df['createdAt'], df['status_num'], alpha=0.6, c=df['status_num'], cmap="tab10")

# Ajustes visuais
plt.title("Dispersão dos Pedidos por Status ao longo do Tempo")
plt.xlabel("Data do Pedido")
plt.ylabel("Status")
plt.yticks(df['status_num'].unique(), le.inverse_transform(df['status_num'].unique()))
#plt.grid(True, linestyle="--", alpha=0.5)
plt.show()

"""#Problema identificado:
###
Cannoli Apresenta dificuldade em demonstrar para seus clientes diretos o impacto positivo da Cannoli em seus negócios. Sendo assim, é possível analisar a quantidade de pedidos realizados e cancelados pelos os clientes, e através dos dados  captados é possível identificar o faturamento das empresas. Portanto, com o auxílio da Inteligência Artificial e aprendizado de máquina é plausível realizar a previsibilidade de faturamento dos pedidos usando o status e os valores e data.
"""